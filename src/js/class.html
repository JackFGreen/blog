<script>
  'use strict'

  function _typeof(obj) {
    '@babel/helpers - typeof'
    if (typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol') {
      _typeof = function _typeof(obj) {
        return typeof obj
      }
    } else {
      _typeof = function _typeof(obj) {
        return obj &&
          typeof Symbol === 'function' &&
          obj.constructor === Symbol &&
          obj !== Symbol.prototype
          ? 'symbol'
          : typeof obj
      }
    }
    return _typeof(obj)
  }

  function _inherits(subClass, superClass) {
    if (typeof superClass !== 'function' && superClass !== null) {
      throw new TypeError('Super expression must either be null or a function')
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: { value: subClass, writable: true, configurable: true },
    })
    console.log(subClass.prototype, subClass)
    // set Parent class -> createSuper -> get Super
    if (superClass) _setPrototypeOf(subClass, superClass)
  }

  function _setPrototypeOf(o, p) {
    _setPrototypeOf =
      Object.setPrototypeOf ||
      function _setPrototypeOf(o, p) {
        o.__proto__ = p
        return o
      }
    return _setPrototypeOf(o, p)
  }

  function _createSuper(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct()
    return function () {
      // get Parent class
      var Super = _getPrototypeOf(Derived),
        result
      console.log(Super)

      // new parent instance
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor
        result = Reflect.construct(Super, arguments, NewTarget)
      } else {
        result = Super.apply(this, arguments)
      }
      return _possibleConstructorReturn(this, result)
    }
  }

  function _possibleConstructorReturn(self, call) {
    if (call && (_typeof(call) === 'object' || typeof call === 'function')) {
      return call
    }
    return _assertThisInitialized(self)
  }

  function _assertThisInitialized(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called")
    }
    return self
  }

  function _isNativeReflectConstruct() {
    if (typeof Reflect === 'undefined' || !Reflect.construct) return false
    if (Reflect.construct.sham) return false
    if (typeof Proxy === 'function') return true
    try {
      Date.prototype.toString.call(Reflect.construct(Date, [], function () {}))
      return true
    } catch (e) {
      return false
    }
  }

  function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf
      ? Object.getPrototypeOf
      : function _getPrototypeOf(o) {
          return o.__proto__ || Object.getPrototypeOf(o)
        }
    return _getPrototypeOf(o)
  }

  function _instanceof(left, right) {
    if (right != null && typeof Symbol !== 'undefined' && right[Symbol.hasInstance]) {
      return !!right[Symbol.hasInstance](left)
    } else {
      return left instanceof right
    }
  }

  function _classCallCheck(instance, Constructor) {
    if (!_instanceof(instance, Constructor)) {
      throw new TypeError('Cannot call a class as a function')
    }
  }

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i]
      descriptor.enumerable = descriptor.enumerable || false
      descriptor.configurable = true
      if ('value' in descriptor) descriptor.writable = true
      Object.defineProperty(target, descriptor.key, descriptor)
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps)
    if (staticProps) _defineProperties(Constructor, staticProps)
    return Constructor
  }

  var Parent = /*#__PURE__*/ (function () {
    function Parent() {
      _classCallCheck(this, Parent)

      this.a = 'a'
    }

    _createClass(Parent, [
      {
        key: 'fn',
        value: function fn() {
          console.log('Parent fn')
        },
      },
    ])

    return Parent
  })()

  var Child = /*#__PURE__*/ (function (_Parent) {
    // set child prototype constructor from parent
    console.log(Child.prototype.fn)
    _inherits(Child, _Parent)
    console.log(Child.prototype.fn)

    var _super = _createSuper(Child)

    function Child() {
      var _this

      _classCallCheck(this, Child)
      // parent.apply(this) -> return parent instance
      _this = _super.call(this)
      _this.b = 'b'
      return _this
    }

    // set self prototype
    _createClass(Child, [
      {
        key: 'fnn',
        value: function fnn() {
          console.log('Child fnn')
        },
      },
    ])

    return Child
  })(Parent)

  var c = new Child()
  console.log(c)
</script>

<script>
  'use strict'

  function _instanceof(left, right) {
    if (right != null && typeof Symbol !== 'undefined' && right[Symbol.hasInstance]) {
      return !!right[Symbol.hasInstance](left)
    } else {
      return left instanceof right
    }
  }

  function _typeof(obj) {
    '@babel/helpers - typeof'
    if (typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol') {
      _typeof = function _typeof(obj) {
        return typeof obj
      }
    } else {
      _typeof = function _typeof(obj) {
        return obj &&
          typeof Symbol === 'function' &&
          obj.constructor === Symbol &&
          obj !== Symbol.prototype
          ? 'symbol'
          : typeof obj
      }
    }
    return _typeof(obj)
  }

  function _classCallCheck(instance, Constructor) {
    if (!_instanceof(instance, Constructor)) {
      throw new TypeError('Cannot call a class as a function')
    }
  }

  function _inherits(subClass, superClass) {
    if (typeof superClass !== 'function' && superClass !== null) {
      throw new TypeError('Super expression must either be null or a function')
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: { value: subClass, writable: true, configurable: true },
    })
    if (superClass) _setPrototypeOf(subClass, superClass)
  }

  function _createSuper(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct()
    return function () {
      var Super = _getPrototypeOf(Derived),
        result
      // if (hasNativeReflectConstruct) {
      //   var NewTarget = _getPrototypeOf(this).constructor
      //   result = Reflect.construct(Super, arguments, NewTarget)
      // } else {
        result = Super.apply(this, arguments)
        console.log(Super)
      // }
      console.log(this, result)
      return _possibleConstructorReturn(this, result)
    }
  }

  function _possibleConstructorReturn(self, call) {
    console.log(self, call)
    if (call && (_typeof(call) === 'object' || typeof call === 'function')) {
      return call
    }
    return _assertThisInitialized(self)
  }

  function _assertThisInitialized(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called")
    }
    return self
  }

  function _wrapNativeSuper(Class) {
    var _cache = typeof Map === 'function' ? new Map() : undefined
    _wrapNativeSuper = function _wrapNativeSuper(Class) {
      if (Class === null || !_isNativeFunction(Class)) return Class
      if (typeof Class !== 'function') {
        throw new TypeError('Super expression must either be null or a function')
      }
      if (typeof _cache !== 'undefined') {
        if (_cache.has(Class)) return _cache.get(Class)
        _cache.set(Class, Wrapper)
      }
      function Wrapper() {
        return _construct(Class, arguments, _getPrototypeOf(this).constructor)
      }
      Wrapper.prototype = Object.create(Class.prototype, {
        constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true },
      })
      return _setPrototypeOf(Wrapper, Class)
    }
    return _wrapNativeSuper(Class)
  }

  function _construct(Parent, args, Class) {
    if (_isNativeReflectConstruct()) {
      _construct = Reflect.construct
    } else {
      _construct = function _construct(Parent, args, Class) {
        var a = [null]
        a.push.apply(a, args)
        var Constructor = Function.bind.apply(Parent, a)
        var instance = new Constructor()
        if (Class) _setPrototypeOf(instance, Class.prototype)
        return instance
      }
    }
    return _construct.apply(null, arguments)
  }

  function _isNativeReflectConstruct() {
    if (typeof Reflect === 'undefined' || !Reflect.construct) return false
    if (Reflect.construct.sham) return false
    if (typeof Proxy === 'function') return true
    try {
      Date.prototype.toString.call(Reflect.construct(Date, [], function () {}))
      return true
    } catch (e) {
      return false
    }
  }

  function _isNativeFunction(fn) {
    return Function.toString.call(fn).indexOf('[native code]') !== -1
  }

  function _setPrototypeOf(o, p) {
    _setPrototypeOf =
      Object.setPrototypeOf ||
      function _setPrototypeOf(o, p) {
        o.__proto__ = p
        return o
      }
    return _setPrototypeOf(o, p)
  }

  function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf
      ? Object.getPrototypeOf
      : function _getPrototypeOf(o) {
          return o.__proto__ || Object.getPrototypeOf(o)
        }
    return _getPrototypeOf(o)
  }

  var myArray = /*#__PURE__*/ (function (_Array) {
    _inherits(myArray, _Array)

    var _super = _createSuper(myArray)

    function myArray() {
      _classCallCheck(this, myArray)

      return _super.apply(this, arguments)
    }

    return myArray
  // })(/*#__PURE__*/ _wrapNativeSuper(Array))
  })(/*#__PURE__*/ Array)

  console.log(new myArray(3))
</script>
